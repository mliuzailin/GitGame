/*==========================================================================*/
/*==========================================================================*/
/*!
	@file	TemplateList.cs
	@brief	汎用動的リスト
	@author Developer
	@date 	2013/04/11
	
	基本部分はNGUIのBetterList.csから。
	NGUIバージョンアップに巻き込まれないように相似クラスとして作成。
	
	■定義
	TemplateList< Vector3 > acVerts = new TemplateList< Vector3 >();
	
	■追加
	acVerts.Add(w);
	
	■ソート
	static int CompareFunc (Vector3 a, Vector3 b)
	{
		if (a.z < b.z) return 1;
		if (a.z > b.z) return -1;
		return 0;
	}
	acVerts.Sort( CompareFunc );
	
	
*/
/*==========================================================================*/
/*==========================================================================*/
/*==========================================================================*/
/*		Using																*/
/*==========================================================================*/
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;

/*==========================================================================*/
/*		namespace Begin 													*/
/*==========================================================================*/
/*==========================================================================*/
/*		define																*/
/*==========================================================================*/
/*==========================================================================*/
/*		macro																*/
/*==========================================================================*/
/*==========================================================================*/
/*		class																*/
/*==========================================================================*/
//----------------------------------------------------------------------------
/*!
	@brief	汎用動的リスト
*/
//----------------------------------------------------------------------------
public class TemplateList<T>
{
    /*==========================================================================*/
    /*		var																	*/
    /*==========================================================================*/
    public T[] m_Buffer = null;
    public int m_BufferSize = 0;

    //------------------------------------------------
    // ※※※※※※※※※※※※※※※※※※※※※※
    // ローカルセーブとして文字列セーブしてJsonで構造体化する対象クラス。
    // 変数の削減によって解析エラーが発生するようになるため、扱いには注意すること。
    // ※※※※※※※※※※※※※※※※※※※※※※
    //------------------------------------------------

    /*==========================================================================*/
    /*		func																*/
    /*==========================================================================*/
    //----------------------------------------------------------------------------
    /*!
		@brief	
	*/
    //----------------------------------------------------------------------------
    /*
	public IEnumerator<T> GetEnumerator ()
	{
		if( m_Buffer != null )
		{
			for( int i = 0; i < m_BufferSize; ++i )
			{
				yield return m_Buffer[i];
			}
		}
	}
	*/

    //----------------------------------------------------------------------------
    /*!
		@brief	コンストラクタ
	*/
    //----------------------------------------------------------------------------
    public TemplateList()
    {
        m_Buffer = null;
        m_BufferSize = 0;
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	コンストラクタ
	*/
    //----------------------------------------------------------------------------
    public TemplateList(T[] acBuffer0, T[] acBuffer1)
    {
        if (acBuffer0 == null)
        {
            m_Buffer = acBuffer1;
        }
        else if (acBuffer1 == null)
        {
            m_Buffer = acBuffer0;
        }
        else
        {
            m_Buffer = new T[acBuffer0.Length + acBuffer1.Length];

            int nInputTotal = 0;
            for (int i = 0; i < acBuffer0.Length; i++) { m_Buffer[nInputTotal] = acBuffer0[i]; nInputTotal++; }
            for (int i = 0; i < acBuffer1.Length; i++) { m_Buffer[nInputTotal] = acBuffer1[i]; nInputTotal++; }
        }
        m_BufferSize = m_Buffer.Length;
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	コンストラクタ
	*/
    //----------------------------------------------------------------------------
    public TemplateList(T[] acBuffer0)
    {
        m_Buffer = acBuffer0;

        if (m_Buffer != null)
        {
            m_BufferSize = m_Buffer.Length;
        }
        else
        {
            m_BufferSize = 0;
        }
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	ゲッターセッター
	*/
    //----------------------------------------------------------------------------
    public T this[int i]
    {
        get { return m_Buffer[i]; }
        set { m_Buffer[i] = value; }
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	配列データの入力件数クリア
		@note	配列は残ってる。入力した情報のみ意味がないものになる
	*/
    //----------------------------------------------------------------------------
    public void Clear()
    {
        m_BufferSize = 0;
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	配列データ全破棄
	*/
    //----------------------------------------------------------------------------
    public void Release()
    {
        //-------------------
        // 配列データ全破棄
        //-------------------
        m_BufferSize = 0;
        m_Buffer = null;
    }


    //----------------------------------------------------------------------------
    /*!
		@brief	配列を固定サイズで再構築
	*/
    //----------------------------------------------------------------------------
    public void Alloc(int nMaxSize)
    {
        //-------------------
        // 配列確保
        //-------------------
        m_Buffer = new T[nMaxSize];
        m_BufferSize = 0;
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	バッファの最後尾に要素追加
	*/
    //----------------------------------------------------------------------------
    public int Add(T cItem)
    {
        //-------------------
        // バッファがサイズ的に追加不可能なら領域拡張
        //-------------------
        if (m_Buffer == null
        || m_BufferSize >= m_Buffer.Length
        )
        {
            AllocateMore();
        }

        //-------------------
        // 最後尾にデータ追加
        //-------------------
        m_Buffer[m_BufferSize] = cItem;
        m_BufferSize++;

        return (m_BufferSize - 1);
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	指定番号の位置に指定要素を挿入
	*/
    //----------------------------------------------------------------------------
    public void Insert(int nIndex, T cItem)
    {
        //-------------------
        // バッファがサイズ的に追加不可能なら領域拡張
        //-------------------
        if (m_Buffer == null
        || m_BufferSize == m_Buffer.Length
        )
        {
            AllocateMore();
        }

        //-------------------
        // 
        //-------------------
        if (nIndex < m_BufferSize)
        {
            //-------------------
            // 指定番号以上の件数データが存在する
            // →指定番号より上のデータを後ろに１個ずらして空いたとこに入力
            //-------------------
            for (int i = m_BufferSize; i > nIndex; --i)
            {
                m_Buffer[i] = m_Buffer[i - 1];
            }
            m_Buffer[nIndex] = cItem;
            m_BufferSize++;
        }
        else
        {
            //-------------------
            // 指定番号以下のデータしか存在しない
            // →最後尾にデータ追加
            //-------------------
            Add(cItem);
        }
    }


    //----------------------------------------------------------------------------
    /*!
		@brief	指定要素が配列中に存在するかチェック
	*/
    //----------------------------------------------------------------------------
    public bool Contains(T item)
    {
        if (m_Buffer == null)
            return false;

        //-------------------
        // 一致する要素を探して存在してたらtrue返す
        //-------------------
        for (int i = 0; i < m_BufferSize; ++i)
        {
            if (m_Buffer[i].Equals(item) == false)
                continue;
            return true;
        }
        return false;
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	指定要素のデータを破棄して前詰め
	*/
    //----------------------------------------------------------------------------
    public bool Remove(T cItem)
    {
        if (m_Buffer == null)
        {
            return false;
        }

        //-------------------
        // 一致する要素を探して配列番号指定で破棄
        //-------------------
        EqualityComparer<T> cComparer = EqualityComparer<T>.Default;
        for (int i = 0; i < m_BufferSize; ++i)
        {
            if (cComparer.Equals(m_Buffer[i], cItem) == false)
            {
                continue;
            }

            RemoveAt(i);
            return true;
        }
        return false;
    }


    //----------------------------------------------------------------------------
    /*!
		@brief	指定番号のデータを破棄して前詰め
	*/
    //----------------------------------------------------------------------------
    public void RemoveAt(int nIndex)
    {
        if (m_Buffer == null)
            return;
        if (m_BufferSize <= nIndex)
            return;

        //-------------------
        // バッファを破棄
        //-------------------
        --m_BufferSize;
        m_Buffer[nIndex] = default(T);

        //-------------------
        // バッファを前詰め
        //-------------------
        for (int i = nIndex; i < m_BufferSize; ++i)
        {
            m_Buffer[i] = m_Buffer[i + 1];
        }
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	配列サイズをデータ数に合わせて正規化して返す
	*/
    //----------------------------------------------------------------------------
    public T[] ToArray()
    {
        Trim();
        return m_Buffer;
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	配列のMAXサイズを取得
	*/
    //----------------------------------------------------------------------------
    public int GetLength()
    {
        if (m_Buffer == null)
        {
            return 0;
        }
        else
        {
            return m_Buffer.Length;
        }
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	配列の内包チェック
	*/
    //----------------------------------------------------------------------------
    public bool ChkInside(System.Comparison<T> fnComparer, T tTarget)
    {
        for (int i = 0; i < m_BufferSize; ++i)
        {
            if (fnComparer.Invoke(m_Buffer[i], tTarget) <= 0)
            {
                continue;
            }

            return true;
        }

        return false;
    }

    private class Comparer : System.Collections.IComparer
    {
        System.Comparison<T> mCompare;


        public Comparer(System.Comparison<T> comparer)
        {
            mCompare = comparer;
        }

        public int Compare(object x, object y)
        {
            return mCompare((T)x, (T)y);
        }
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	配列のソート実行
	*/
    //----------------------------------------------------------------------------
    public void Sort(System.Comparison<T> fnComparer)
    {
        if (m_Buffer == null)
        {
            return;
        }

        System.Array.Sort(m_Buffer, 0, m_BufferSize, new Comparer(fnComparer));
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	配列のソート実行
	*/
    //----------------------------------------------------------------------------
    public void Sort(System.Comparison<T> fnComparer, System.Action<T> fnCreateSortNum)
    {
        if (m_Buffer == null)
        {
            return;
        }

        //-------------------
        // ソートに使用する番号を構築
        //-------------------
        for (int i = 0; i < m_BufferSize; ++i)
        {
            fnCreateSortNum.Invoke(m_Buffer[i]);
        }

        System.Array.Sort(m_Buffer, 0, m_BufferSize, new Comparer(fnComparer));
    }




    //----------------------------------------------------------------------------
    /*!
		@brief	配列のリサイズ処理
		@note	既に配列が存在するなら倍サイズ、存在しないなら32で配列を確保し直す。
				既に配列が存在するなら確保した配列に対して値のコピーも行う
	*/
    //----------------------------------------------------------------------------
    private void AllocateMore()
    {
        //-------------------
        // 配列確保
        //-------------------
        T[] acNewList = null;
        if (m_Buffer != null)
        {
            //			Debug.LogError( m_BufferSize + " / " + Mathf.Max(m_Buffer.Length << 1, 32) );
            acNewList = new T[Mathf.Max(m_Buffer.Length << 1, 32)];
        }
        else
        {
            acNewList = new T[32];
        }

        //-------------------
        // バッファが既存なら値コピー
        //-------------------
        if (m_Buffer != null
        && m_BufferSize > 0
        )
        {
            m_Buffer.CopyTo(acNewList, 0);
        }

        //-------------------
        // バッファを新しいものに置き換え
        //-------------------
        m_Buffer = acNewList;
    }

    //----------------------------------------------------------------------------
    /*!
		@brief	バッファを入力データ数にぴったりのサイズで構築し直す
	*/
    //----------------------------------------------------------------------------
    private void Trim()
    {
        //-------------------
        // 
        //-------------------
        if (m_BufferSize > 0)
        {
            //-------------------
            // バッファのMAXサイズより入力データが少ない場合
            // 入力データ数で配列を作って差替える
            //-------------------
            if (m_BufferSize < m_Buffer.Length)
            {
                T[] acNewList = new T[m_BufferSize];
                for (int i = 0; i < m_BufferSize; ++i)
                {
                    acNewList[i] = m_Buffer[i];
                }
                m_Buffer = acNewList;
            }
        }
        else
        {
            m_Buffer = null;
        }
    }

}

